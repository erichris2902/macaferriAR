<!DOCTYPE html>
<meta name="viewport" content="width=device-width, height=device-height, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<!-- three.js library -->
<script src='build/three.min.js'></script>
<!-- ar.js -->
<script src="build/ar-threex.js"></script>
<script>THREEx.ArToolkitContext.baseURL = '../'</script>

<body style='font-family: Monospace;'>
<script type="importmap">
    {
        "imports": {
            "three": "./build/three.module.js",
            "three/addons/": "./jsm/"
        }
    }
</script>
<script type="module">
    import * as THREE from 'three';
    import {RoomEnvironment} from 'three/addons/environments/RoomEnvironment.js';

    import {GLTFLoader} from 'three/addons/loaders/GLTFLoader.js';
    import {DRACOLoader} from 'three/addons/loaders/DRACOLoader.js';

    //////////////////////////////////////////////////////////////////////////////////
    //		Init
    //////////////////////////////////////////////////////////////////////////////////
    let mixer;

    const simulation = "macarmour";

    const clock = new THREE.Clock();

    // init renderer
    var renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
        logarithmicDepthBuffer: true
    });
    renderer.setClearColor(new THREE.Color('lightgrey'), 0)
    renderer.setSize(1280, 960);
    renderer.domElement.style.position = 'absolute'
    renderer.domElement.style.top = '0px'
    renderer.domElement.style.left = '0px'
    document.body.appendChild(renderer.domElement);

    // array of functions for the rendering loop
    var onRenderFcts = [];
    var arToolkitContext, arMarkerControls;

    const pmremGenerator = new THREE.PMREMGenerator(renderer);

    // init scene and camera
    var scene = new THREE.Scene();

    scene.environment = pmremGenerator.fromScene(new RoomEnvironment(renderer), 0.04).texture;

    //////////////////////////////////////////////////////////////////////////////////
    //		Initialize a basic camera
    //////////////////////////////////////////////////////////////////////////////////

    // Create a camera
    var camera = new THREE.PerspectiveCamera();
    scene.add(camera);

    ////////////////////////////////////////////////////////////////////////////////
    //          handle arToolkitSource
    ////////////////////////////////////////////////////////////////////////////////

    var arToolkitSource = new THREEx.ArToolkitSource({
        // to read from the webcam
        sourceType: 'webcam',

        sourceWidth: window.innerWidth > window.innerHeight ? 1280 : 960,
        sourceHeight: window.innerWidth > window.innerHeight ? 960 : 1280,

        // // to read from an image
        // sourceType : 'image',
        // sourceUrl : THREEx.ArToolkitContext.baseURL + '../data/images/img.jpg',

        // to read from a video
        // sourceType : 'video',
        // sourceUrl : THREEx.ArToolkitContext.baseURL + '../data/videos/headtracking.mp4',
    })

    arToolkitSource.init(function onReady() {
        arToolkitSource.domElement.addEventListener('canplay', () => {
            console.log(
                'canplay',
                'actual source dimensions',
                arToolkitSource.domElement.videoWidth,
                arToolkitSource.domElement.videoHeight
            );

            initARContext();
        });
        window.arToolkitSource = arToolkitSource;
        setTimeout(() => {
            onResize()
        }, 2000);
    })

    // handle resize
    window.addEventListener('resize', function () {
        onResize()
    })

    function onResize() {
        arToolkitSource.onResizeElement()
        arToolkitSource.copyElementSizeTo(renderer.domElement)
        if (window.arToolkitContext.arController !== null) {
            arToolkitSource.copyElementSizeTo(window.arToolkitContext.arController.canvas)
        }
    }
    ////////////////////////////////////////////////////////////////////////////////
    //          initialize arToolkitContext
    ////////////////////////////////////////////////////////////////////////////////


    function initARContext() { // create atToolkitContext
        arToolkitContext = new THREEx.ArToolkitContext({
            cameraParametersUrl: 'camera_para.dat',
            detectionMode: 'mono'
        })
        // initialize it
        arToolkitContext.init(() => { // copy projection matrix to camera
            camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());

            arToolkitContext.arController.orientation = getSourceOrientation();
            arToolkitContext.arController.options.orientation = getSourceOrientation();

            console.log('arToolkitContext', arToolkitContext);
            window.arToolkitContext = arToolkitContext;
        })

        // MARKER
        arMarkerControls = new THREEx.ArMarkerControls(arToolkitContext, camera, {
            type: 'pattern',
            patternUrl: THREEx.ArToolkitContext.baseURL + 'pattern-marker.patt',
            // patternUrl : THREEx.ArToolkitContext.baseURL + '../data/data/patt.kanji',
            // as we controls the camera, set changeMatrixMode: 'cameraTransformMatrix'
            changeMatrixMode: 'cameraTransformMatrix'
        })

        scene.visible = false

        console.log('ArMarkerControls', arMarkerControls);
        window.arMarkerControls = arMarkerControls;
    }


    function getSourceOrientation() {
        if (!arToolkitSource) {
            return null;
        }

        console.log(
            'actual source dimensions',
            arToolkitSource.domElement.videoWidth,
            arToolkitSource.domElement.videoHeight
        );

        if (arToolkitSource.domElement.videoWidth > arToolkitSource.domElement.videoHeight) {
            console.log('source orientation', 'landscape');
            return 'landscape';
        } else {
            console.log('source orientation', 'portrait');
            return 'portrait';
        }
    }

    // update artoolkit on every frame
    onRenderFcts.push(function () {
        if (!arToolkitContext || !arToolkitSource || !arToolkitSource.ready) {
            return;
        }

        arToolkitContext.update(arToolkitSource.domElement)

        // update scene.visible if the marker is seen
        scene.visible = camera.visible
    })

    //////////////////////////////////////////////////////////////////////////////////
    //		add an object in the scene
    //////////////////////////////////////////////////////////////////////////////////

    const dracoLoader = new DRACOLoader();
    dracoLoader.setDecoderPath('jsm/libs/draco/gltf/');

    const loader = new GLTFLoader();
    loader.setDRACOLoader(dracoLoader);
    loader.load('models/br_macarmour.glb', function (gltf) {
        const model = gltf.scene;
        model.position.set(0, 0, 0);
        model.scale.set(1, 1, 1);
        scene.add(model);

        mixer = new THREE.AnimationMixer(model);
        for (var anim in gltf.animations) {
            console.log(anim);
            mixer.clipAction(gltf.animations[anim]).play();
        }
        mixer.clipAction(gltf.animations[0]).play();
        console.log(gltf.animations);
        //animate();

    }, undefined, function (e) {
        console.error(e);
    });

    //////////////////////////////////////////////////////////////////////////////////
    //		render the whole thing on the page
    //////////////////////////////////////////////////////////////////////////////////

    // render the scene
    onRenderFcts.push(function () {
        renderer.render(scene, camera);
    })

    // run the rendering loop
    var lastTimeMsec = null
    requestAnimationFrame(function animate(nowMsec) {
        // keep looping
        requestAnimationFrame(animate);
        // measure time
        lastTimeMsec = lastTimeMsec || nowMsec - 1000 / 60
        var deltaMsec = Math.min(200, nowMsec - lastTimeMsec)
        lastTimeMsec = nowMsec



        if(mixer != null){
            const delta = clock.getDelta();
            mixer.update(delta);
        }

        // call each update function
        onRenderFcts.forEach(function (onRenderFct) {
            onRenderFct(deltaMsec / 1000, nowMsec / 1000)
        })
    })

    const raycaster = new THREE.Raycaster();
    raycaster.precision = 0.005;
    const mouse = new THREE.Vector2();
    renderer.domElement.addEventListener('click', onClick, false);

    function onClick(event) {
        // Calcula las coordenadas normalizadas del clic del usuario
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        // Actualiza el rayo con la posición y dirección de la cámara
        raycaster.setFromCamera(mouse, camera);

        // Intersecta con los objetos en la escena
        const intersects = raycaster.intersectObjects(scene.children);

        if (intersects.length > 0) {
            // Se hizo clic en un objeto
            const clickedObject = intersects[0].object;
            console.log('Objeto clickeado:', clickedObject);
            // Realiza acciones adicionales según tus necesidades

            if (clickedObject.name == "pdf") {
                if (simulation == "steelgrid") {
                    window.open("https://drive.google.com/file/d/1UnFFWVOpHBGHW43DIfqpoAbDIq1N6VBS/view?usp=sharing", "_blank");
                } else {
                    window.open("https://drive.google.com/file/d/1jf7jicsqLOQMBwVHWuie0Zb-GK9VT70d/view?usp=sharing", "_blank");
                }
            } else if (clickedObject.name == "return") {
                if (simulation == "steelgrid") {
                    window.open("index.html",'_self');
                } else {
                    window.open("index.html",'_self');
                }
            } else if (clickedObject.name == "change") {
                if (simulation == "steelgrid") {
                    window.open("fall.html",'_self');
                } else {
                    window.open("fall.html",'_self');
                }
            }
        }
    }
</script>
</body>